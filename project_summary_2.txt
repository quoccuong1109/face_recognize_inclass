            --- Start of attendance.py ---
import os
import json
from flask import request, jsonify, render_template, Response
import cv2
import numpy as np
from tensorflow.keras.models import load_model
from app import app

model_path = os.path.join('models', 'face_recognition_model.h5')

# Kiểm tra nếu model tồn tại
if os.path.exists(model_path):
    model = load_model(model_path)
    print("Mô hình đã được tải thành công.")
else:
    model = None
    print("Không tìm thấy tệp mô hình.")

# Đọc dữ liệu học sinh từ tệp JSON
students_file = 'students.json'
students_data = []
if os.path.exists(students_file):
    with open(students_file, 'r', encoding='utf-8') as file:
        try:
            students_data = json.load(file)
        except json.JSONDecodeError:
            students_data = []

@app.route('/diemdanh_tudong')
def diemdanh_tudong():
    return render_template('diemdanh_tudong.html')

@app.route('/attendance_feed')
def attendance_feed():
    return Response(gen_attendance_frames(), mimetype='multipart/x-mixed-replace; boundary=frame')

def gen_attendance_frames():
    if not model:
        raise Exception("Model chưa được huấn luyện. Vui lòng huấn luyện mô hình trước khi điểm danh.")

    camera = cv2.VideoCapture(0)
    if not camera.isOpened():
        raise Exception("Không thể mở camera")

    while True:
        success, frame = camera.read()
        if not success:
            break
        gray = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)
        face_cascade = cv2.CascadeClassifier(cv2.data.haarcascades + 'haarcascade_frontalface_default.xml')
        faces = face_cascade.detectMultiScale(gray, 1.1, 4)
        
        print(f"Detected faces: {faces}")  # In ra để kiểm tra

        names = []
        for (x, y, w, h) in faces:
            face_img = frame[y:y+h, x:x+w]
            face_img = cv2.resize(face_img, (128, 128))
            face_img = cv2.cvtColor(face_img, cv2.COLOR_BGR2GRAY)  # Chuyển đổi sang grayscale nếu cần
            face_img = face_img / 255.0
            face_img = face_img.reshape(1, 128, 128, 1)  # Đảm bảo định dạng đầu vào đúng
            
            predicted_prob = model.predict(face_img)[0]
            predicted_id = np.argmax(predicted_prob)
            confidence = np.max(predicted_prob) * 100  # Tính toán tỷ lệ chính xác
            name = next((student['name'] for student in students_data if student['id'] == predicted_id), "Unknown")
            names.append(name)
            
            print(f"Predicted name: {name}, Confidence: {confidence}")  # In ra để kiểm tra
            
            cv2.rectangle(frame, (x, y), (x+w, y+h), (255, 0, 0), 2)
            cv2.putText(frame, f'{name} ({confidence:.2f}%)', (x, y-10), cv2.FONT_HERSHEY_SIMPLEX, 0.9, (255, 0, 0), 2)
        
        ret, buffer = cv2.imencode('.jpg', frame)
        frame = buffer.tobytes()
        
        yield (b'--frame\r\n'
               b'Content-Type: image/jpeg\r\n\r\n' + frame + b'\r\n')
    
    camera.release()

@app.route('/get_attendance', methods=['GET'])
def get_attendance():
    return jsonify({'students': students_data})            --- End of attendance.py ---
            --- Start of delete_data.py ---
import os
import json
import shutil
from flask import Blueprint, jsonify, request

delete_data_bp = Blueprint('delete_data', __name__)

@delete_data_bp.route('/delete_data', methods=['POST'])
def delete_data():
    try:
        # Xóa model hiện tại
        model_path = 'models/face_recognition_model.h5'
        if os.path.exists(model_path):
            os.remove(model_path)
        else:
            print(f"Model path {model_path} does not exist.")

        # Xóa dữ liệu ảnh hiện có
        data_folders = ['data/processed_images', 'data/raw_images']
        for folder in data_folders:
            if os.path.exists(folder):
                for root, dirs, files in os.walk(folder):
                    for dir in dirs:
                        os.chmod(os.path.join(root, dir), 0o777)
                    for file in files:
                        os.chmod(os.path.join(root, file), 0o777)
                shutil.rmtree(folder)
                os.makedirs(folder)  # Tạo lại thư mục rỗng sau khi xóa
            else:
                print(f"Data folder {folder} does not exist.")

        # Reset ID về 1
        with open('current_id.json', 'w', encoding='utf-8') as file:
            json.dump({'current_id': 0}, file, ensure_ascii=False)

        # Xóa nội dung trong tệp students.json
        with open('students.json', 'w', encoding='utf-8') as file:
            json.dump([], file, ensure_ascii=False)

        return jsonify({'message': 'Đã xóa hết dữ liệu học sinh, reset ID về 1 và xóa các hình ảnh đã chụp thành công!'})
    except Exception as e:
        print(f"Error occurred: {str(e)}")
        return jsonify({'message': f'Có lỗi xảy ra khi xóa dữ liệu: {str(e)}'}), 500

if __name__ == '__main__':
    from flask import Flask
    app = Flask(__name__)
    app.register_blueprint(delete_data_bp)
    app.run(debug=True)            --- End of delete_data.py ---
            --- Start of get_next_id.py ---
from flask import jsonify
from app import app
import os
import json

def get_next_id():
    current_id = 0
    if os.path.exists('current_id.json'):
        with open('current_id.json', 'r') as file:
            current_id = json.load(file).get('current_id', 0)
    next_id = current_id + 1
    with open('current_id.json', 'w') as file:
        json.dump({'current_id': next_id}, file)
    return next_id

@app.route('/get_next_id', methods=['GET'])
def get_next_id_route():
    next_id = get_next_id()
    return jsonify({'next_id': next_id})            --- End of get_next_id.py ---
            --- Start of home.py ---
from flask import render_template
from app import app

@app.route('/')
def home():
    return render_template('index.html')            --- End of home.py ---
            --- Start of train_model.py ---
from flask import request, jsonify
from app import app
import os
import cv2
import numpy as np
from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import Conv2D, MaxPooling2D, Flatten, Dense
import imgaug.augmenters as iaa
from sklearn.model_selection import train_test_split
import matplotlib.pyplot as plt

model_path = 'models/face_recognition_model.h5'

@app.route('/train_model', methods=['POST'])
def train_model_route():
    try:
        preprocess_images('data/raw_images', 'data/processed_images')
        augment_images('data/processed_images', 'data/augmented_images')
        images, labels = load_data('data/augmented_images')
        images = images.reshape(-1, 128, 128, 1)

        # Tách dữ liệu thành tập huấn luyện và tập kiểm tra
        X_train, X_test, y_train, y_test = train_test_split(images, labels, test_size=0.2, random_state=42)

        print(f"Labels: {labels}")  # In ra để kiểm tra

        model = Sequential([
            Conv2D(32, (3, 3), activation='relu', input_shape=(128, 128, 1)),
            MaxPooling2D((2, 2)),
            Conv2D(64, (3, 3), activation='relu'),
            MaxPooling2D((2, 2)),
            Flatten(),
            Dense(128, activation='relu'),
            Dense(len(set(labels)), activation='softmax')
        ])

        model.compile(optimizer='adam', loss='sparse_categorical_crossentropy', metrics=['accuracy'])
        model.fit(X_train, y_train, epochs=10, validation_split=0.2)

        # Đánh giá mô hình với tập kiểm tra
        test_loss, test_accuracy = model.evaluate(X_test, y_test)
        print(f'Test accuracy: {test_accuracy}')

        # Kiểm tra các trường hợp dự đoán sai
        y_pred = model.predict(X_test)
        y_pred_classes = np.argmax(y_pred, axis=1)
        incorrect_indices = np.where(y_pred_classes != y_test)[0]

        for i in incorrect_indices:
            print(f'Actual: {y_test[i]}, Predicted: {y_pred_classes[i]}')
            plt.imshow(X_test[i].reshape(128, 128), cmap='gray')
            plt.title(f'Actual: {y_test[i]}, Predicted: {y_pred_classes[i]}')
            plt.show()

        model.save(model_path)
        return jsonify({'message': 'Đã huấn luyện và lưu mô hình thành công!', 'test_accuracy': test_accuracy})
    except Exception as e:
        return jsonify({'message': f'Có lỗi xảy ra khi huấn luyện mô hình: {str(e)}'}), 500

def preprocess_images(input_folder, output_folder):
    if not os.path.exists(output_folder):
        os.makedirs(output_folder)

    for root, dirs, files in os.walk(input_folder):
        for file in files:
            file_path = os.path.join(root, file)
            img = cv2.imread(file_path)
            if img is None:
                continue
            gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)
            resized = cv2.resize(gray, (128, 128))
            output_path = os.path.join(output_folder, file)
            cv2.imwrite(output_path, resized)

def augment_images(input_folder, output_folder):
    if not os.path.exists(output_folder):
        os.makedirs(output_folder)

    seq = iaa.Sequential([
        iaa.Fliplr(0.5),  # Lật ngang hình ảnh với xác suất 50%
        iaa.Affine(rotate=(-20, 20)),  # Xoay hình ảnh trong khoảng -20 đến 20 độ
        iaa.Multiply((0.8, 1.2)),  # Thay đổi độ sáng của hình ảnh
        iaa.GaussianBlur(sigma=(0, 1.0))  # Làm mờ hình ảnh với độ mờ ngẫu nhiên
    ])

    for root, dirs, files in os.walk(input_folder):
        for file in files:
            file_path = os.path.join(root, file)
            img = cv2.imread(file_path)
            if img is None:
                continue
            images_aug = seq(images=[img] * 5)  # Tạo 5 biến thể của mỗi hình ảnh
            for i, img_aug in enumerate(images_aug):
                output_path = os.path.join(output_folder, f"{os.path.splitext(file)[0]}_aug_{i}.jpg")
                cv2.imwrite(output_path, img_aug)

def load_data(data_folder):
    images = []
    labels = []
    for root, dirs, files in os.walk(data_folder):
        for file in files:
            file_path = os.path.join(root, file)
            img = cv2.imread(file_path, cv2.IMREAD_GRAYSCALE)
            img = img / 255.0
            images.append(img)
            label = int(file.split('_')[0]) - 1  # Đảm bảo nhãn bắt đầu từ 0
            labels.append(label)
    return np.array(images), np.array(labels)            --- End of train_model.py ---
